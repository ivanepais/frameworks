/*
	|| NORMAL FLOW

		Los elementos en bloque tienen dos direcciones: block-direction (como aparecen las cajas) y inline-direction (direción hacia donde fluye el contenido).	
		La propiedad writing-mode determina las dirección de los elementos en los metodos de diseño.
		La propiedad display cambia los metodos de diseño.
		Las direction y text-direction son parecidas a writing-mode.		

		Los contexto de formato determina el comportamiento de los elementos en bloque y en línea:
			
			en bloque:
			Los margenes verticales crean una separación, si aplicamos margin: 0; elimina los margen en los cuatro lados, se juntarán las cajas.
			El contenido de los elementos en bloque ocupará todo el espacio que haya en el contenedor del bloque, hacia donde fluya la dirección de este.
			Aparecerán uno debajo de otro, incluso si para dos elementos determinamos un ancho para que entren los dos.
			
			en línea:
			Se muestran uno tras otro en la dirección de contenido que disponga el modo de escritura que se esté usando.
			Solo podemos aplicar propiedades horizontales del model box (izq y der: width (content área), padding, margin)
			Solo le podemos dar altura si cambiamos el tamaño de fuente para su contenido.
			
			*Los dos tipos de elementos tienen un principio y final que es importante para las propiedades lógicas.	

			Colapso de margen:
			Cuando los margenes top y bottom se tocan, que uno solo: el más grande. Aunque hay más casos.
			
			Elementos de reemplazo (img, video, etc):
			No cambian su orientación/visualización por el modo de escritura.

		Display: define los tipos de visualización 

			exterior:
			Determina como se comporta la caja con respecto a las demás cajas dentro de ese mismo contexto de formato.
			
			interior:
			Determina como se comportan las cajas/elementos dentro de este elemento.
		
		Propiedades lógicas:
		block-size, inline-size y las demás se adaptan bien a los valores de display y writing-mode.

		Elementos del HTML:
		El elemento HTML crea el contexto de diseño/formato inicial para que los elementos esten dentro de la página.	
		Seguirán el comportamiento del normal flow, a menos que con algunas propiedades o algunos valores de display podamos sacarlos de este contexto para crear otros con distintos comportamientos.

			In flow:
			Elementos que pertenecen al contexto inicial creado por la etiqueta HTML.

			Out flow:
			Elementos que pueden salir del flujo con float, position fixed y absolute, etc.
			Podrán superponerse con los elementos que están en el contexto inicial.
			
			BFC (block formatting context):
			Hay propiedades que pueden crear estos elementos especiales que son mini html que estan fuera del principal que exteriormente sigue un comportamiento de bloque.
			Por ejemplo, un float o los item de grid o flex son bfc.

		Desbordamiento/overflow:
		Hay más contenido del que cabe en un contenedor de tamaño restringuido.
		En el flujo normal, darle a un elemento una altura y un ancho fijos genera un desbordamiento.
		
		Por defecto la propiedad overflow está en visible.
		Podemos ocultarlo (hidden) o poner barras horizontal y vertical(scroll) y auto (pone barras cuando son necesarias).
		overflow es abreviada de overflow-x y overflow-y.
		Todas estas crean un nuevo BFC.

		Pero tambien hay otras propiedades que se adaptan al texto o al caja para que no se desborde.
		Como white-space, overflow-wrap, word-break, width: fit-content, width: max-content.
		
		*Estas propiedades no hacen falta en un texto no dinamico/contralado usuario. 
		 Si en una caja definimos ancho pero no alto y la palabra más larga no supera el ancho de la caja, la altura de la caja se ajusta automaticamente al texto;
			
			Ej: Para un parrafo en una caja:
				
				<div class="box">
    			<p>One November night in the year 1782, so the story runs, two brothers sat over their winter fire in the little French town of Annonay, watching the grey smoke-wreaths from the hearth curl up the wide chimney.</p>
				</div>

				.box {
				    width: 300px;
				    border: 5px solid rebeccapurple;
				    padding: 10px;
				}

				.box p {
				    
				    // no harián falta //

				    white-space: nowrap;
				    text-overflow: ellipsis;
				    overflow: hidden;
				}

		Para propiedades lógicas:
		Son como block-size e inline-size que reemplazan a height y width.

			overflow-block:
			Reemplaza a la propiedad vertical, overflow-y

			overflow-inline:
			reemplaza a la propiedad overflow-x.
		
		*Todavía no están implementadas, se deben usar las físicas y ajustar el modo de escritura.
		
		Propiedades para los ejes:
			
			En bloque:
			block-overflow, no está aprobada.

			En línea:
			text-overflow: siempre evitará el desbordamiento. Para que funcione necesitamos algunos valores de las propiedades white-space y overflow.					
								
				.box p {
				    white-space: nowrap;
				    text-overflow: ellipsis;
				    overflow: hidden;
				}

			Todos los valores cortan el texto:
				
				clip: Puede ocurrir en medio de un carácter.

				ellipsis: Antes agrega puntos suspensivos.
				
				text-overflow: "-"; agregará un guión.

				text-overflow: ""; impide que corte el texto en medio de una palabra.
		
	|| Modelo de formato visual:
		Describe como los navegadores leen el DOM (árbol del documento) y lo muestran para los medios visuales (continuous media) una página, audio, video; y medios páginados (paged media) como puede ser un pdf para imprimir, un libro, etc.
		Los elementos del DOM o del documento (web, pdf, etc) tienen un orden de renderizado:

			1. Las cajas de CSS y su tamaño
			2. Su posicionamiento en normal flow, float y position absolute.
			3. Relaciones entre elementos en el árbol del documento.
			4. Información externa (tamaño del viewport, tamaño de imagenes).

		Cajas anonimas
		Son elementos que no podemos diseñar con CSS porque no tienen etiqueta de HTML.
			
			Casos:
			1° Hay un elemento de HTML para usar en una caja. Por ejemplo, cuando declaras display flex en un contenedor/elemento principal y hay texto que no está encerrado en un parrafo. El arbol de cajas, creará una caja anonima para contener ese texto. Se comportará como un elemento flexible pero no se puede diseñar como una caja normal porque no podemos llamar al contenido suelto.
			2° Lo mismo puede suceder cuando en un div hay contenido de texto suelto sin el elemento parrfo. Y lo mismo pasa con otros metodos de diseño.
			2° Tambien sucede con las cajas en línea cuando hay uno de estos elementos vacio.	


	|| FLEX
		Dispone los elementos sobre un eje vertical u horizontal, por eso es unidimensional.

		Dos ejes:
		El eje principal está definido por flex-direction, y el eje transversal corre en perpendicular (90°) al primero.
		
			Valores de flex-direction:

				row: 
				El eje principal corre en la dirección en línea/texto/contenido. 
				Los items se ordenan en línea, uno al lado de otro.
					
					Su eje secundario correrá en dirección de bloque.

				column: 
				Corre en dirección de bloque/elementos. 
				Los items se ordenan en columna, uno debajo de otro.
					
					El eje secundario correrá en dirección en línea.
				
				column-reverse/row-reverse: dirección contraria.
		
		writing-mode:
		Determina dónde empiezan o terminan los elementos, start/end.

		Valores por defecto:

			Flex-direction: row;
			Los items no crecen pero si se reducen
			Los items crecen en el eje transversal para contener todo el contenido
			flex-basis: auto;
			flex-wrap: nowrap;

		Valores auto / 0:

			auto:
			indica que los elementos toman el tamaño establecido en ellos mismo o si no tienen, su contenido determinará su tamaño.
			
			0: 
			indica que va a ignorar el tamaño "auto" de los elementos (por contenido o por su ancho definido) así comparte todo el espacio disponible (del contenedor) proporcionalmente.

		flex-wrap: wrap;
		Acomoda los elementos en multiples líneas cuando no hay espacio en una sola.
		
		flex-flow: 
		Es abreviada para flex-directión y flex-wrap.
			
			{flex-flow: row wrap;}

		Propiedades para los items:
		Usan el espacio disponible del contenedor flex.
		Tamaño horizonal/vertical del contenedor menos el tamaño de los elementos.
		Si sobra espacio, podemos distribuirlo entre los elementos.

			flex-grow: 
			Agrega/toma espacio del disponible para agrandar elementos.

			flex-shrink:
			Quita espacio para reducir elementos. 

			flex-basis:
			Define el tamaño de los elementos para crecer o reducirse.

				auto: valor por defecto.
				Los elementos toman el tamaño establecido en ellos mismo o si no tienen, su contenido determinará su tamaño.
			
				0: 
				Indica que va a ignorar el tamaño "auto" de los elementos (por contenido o por su ancho definido) así comparte todo el espacio disponible (del contenedor) proporcionalmente.
			
			Flex:
			Abreviada de grow, shink, basis; en este orden.

				Configuraciones:

					flex: 1 o flex: 2
					Es como si usará flex: 1 1 0, o flex: 2 1 0; para los valores flex grow (crecimiento), shrink (reducción) o basis (tamaño). 
					Los elementos pueden crecer o reducirse a partir de una base flexible de 0 (espacio proporcional).

					flex: initial
					Resetea a los valores iniciales que son flex: 0 1, cero para crecimiento, uno para reducción y auto para la base de los valores anteriores.
					
					flex: auto
					Es flex: 1 1 auto, los elementos pueden crecer y reducirse a partir de su tamaño determinado.

					flex: none 
					Es flex: 0 0 auto, se distribuyen en el contenedor utilizando el tamaño mismo de los elementos, debido al valor auto.
			
			Alinear elementos:
				
				justify-content:
				Alinea elementos en el eje principal.

				align-items:
				Para alinear elementos en el eje secundario
			
		Writting mode:
		Flexbox se adapta a los modos de escritura, se usa para cuestiones creativas de diseño ya que estamos en CSSS, no se usa para cambiar el idioma de un documento completo. 
		El idioma se trata desde HTML con los atributos dir y lang para indicar la dirección de texto y su idioma.

		Flexbox y otros metodos:

			Float y cleaner:
			Si el contenedor de un float se convierte flex, no se aplicarán estás propiedades.
			
			Grid:
			Si un elemento flexible se convierte en un elemento de cuadrícula, se ignorarán las propiedades flexibles que se hayan asignado a los elementos secundarios.
			O reemplazar un cuadrícula con flex, para navegadores antiguos.		
				
				   	<div class="box">
				       <div>One</div>
				       <div>Two</div>
				       <div>Three</div>
				    </div>
					
					.box {
			          display: flex;
			          flex-wrap: wrap;
			        }

			        .box>* {
			          flex: 1 1 200px;
			        }
					
					.box {
				        display: grid;
				        grid-template-columns: repeat(auto-fill, minmax(200px, auto));
				    }

				*creamos el mismo diseño en flex y en grid

			Propiedad display: contents
			Si un elemento flexible tiene dos elementos anidados, que normalmente no participarían en el diseño flexible.
			Elimina el diseño o estilo aplicado a a los subitems y tambien el estilo de bloque por fuera que le da el contenedor.

				.box {
		            display: flex;
		        }

		        .nested {
		            background-color: orange;
		            display: contents;
		        }

		|| Alineaciones:
			Dejan el espacio en el eje principal o secundario.
			Segun el flex-direction, los ejes van cambian; el espacio estará en eje de bloque o en el eje de línea. 
			
			Propiedades:

			justify-content: 
			Controla la alineación de todos los elementos en el eje principal (main).</li>
			
			align-items: 
			Controla la alineación de todos los elementos en el eje secundario (cross).</li>
			
			align-self: Controla la alineación de un elemento en el eje secundario.</li>
			
			align-content: 
			Controla el espacio entre las líneas del eje secundario.</li>
			
			gap, column-gap, and row-gap: 
			Crean espacios entre elementos flexibles.
			
			Valores:
				
				justify-content: En eje principal
				
					flex-start
					flex-end
					center
					space-between
					space-around
					space-evenly

				align-items: En eje secundario
					
					flex-start
					flex-end
					center
					stretch
					baseline
				
				align-content: En eje secundario

					flex-start
					flex-end
					center
					space-between
					space-around
					stretch
					space-evenly
			
		Margenes automaticos:
		Para separar un grupo de elementos alineados en un contenedor.
			
			<div class="box">
			  <div>One</div>
			  <div>Two</div>
			  <div>Three</div>
			  <div class="push">Four</div>
			  <div>Five</div>
			</div>	

			.box {
			  display: flex;
			}
			.push {
			    margin-left: auto;
			}
		
		Gaps: espacios entre los elementos

			.box {
			  display: flex;
			  flex-wrap: wrap;
			  row-gap: 10px;
			  column-gap: 2em;
			}

			.box > * {
			  flex: 1;
			}
		
		Orden de los elementos:
		Podemos cambiar el orden de los elementos con flex-direction: row/column-reverse y la propiedad order.
		Pero trae problemas de accesibilidad, el orden leido por el navegador es el del código fuente.
		Solo estamos cambiando el orden visual.
			
			propiedad order:
			Puede tomar elementos individuales y cambiarlos de lugar. 
			Diseñada distribuir los elementos en grupos ordinales.
			A los elementos se les asigna un número entero que representa su grupo, los valores más bajos van primero. Mas de un elemento puede tener el mismo numero de orden (se colocan seguidos, de menor a mayor orden del código fuente).
			Por defecto tienen un valor 0, los que tengan un numero mayor, aparecerán despues de estos.				
			Podemos usar negativos para dejar elementos primeros y a los demás no le asignamos ningun orden.

				externo: 
					
					<div class="box">
            			<div><a href="#">1</a></div>
            			<div><a href="#">2</a></div>
            			<div><a href="#">3</a></div>
            		</div>
					
					.box {
			          display: flex;
			          flex-direction: row;
			        }

			        .box :nth-child(1) { order: 2; }
			        .box :nth-child(2) { order: 3; }
			        .box :nth-child(3) { order: 1; }
				
					negativo:

						box {
				          display: flex;
				          flex-wrap: wrap;
				          flex-direction: row;
				        }

				         <div class="active"><a href="#">3</a></div>
				        .active {
				            order: -1;
				            flex: 1 0 100%;
				        }

				interno:
				Puede ocurrir que el orden logico y de lectura (al mismo tiempo) de los elementos flexibles estén separados del orden visual.
				Unos cuadros que tengan de notificaciones/noticias con un diseño que muestre una fecha, un encabezado y luego un contenido.
				La fecha será un elemento flexible, con valor de order negativo, subimos la fecha por encima del encabezado.
					
					<div class="wrapper">
			        	<div class="card">
			            	<h3>News item title</h3>
			            	<div class="date">1 Nov 2017</div>
			            	<p>This is the content of my news item. Very newsworthy.</p>
			        	</div>
					</div>
					
					.card {
            			display: flex;
            			flex-direction: column;
        			}

        			.date {
                		order: -1;
                		text-align: right;
            		}
		
		La mejor practica es mantener el orden logico, de lectura y tabulación. Tampoco se recomienda usar orden en elementos que se puedan navegar usando el teclado, como son los links.

	|| Tamaño de los elementos flexibles:
		Se relacionan con el tamaño natural de los artículos flexibles antes de que crezca o se encoja, y con el concepto de espacio libre.
			
			Espacio disponible en el contenedor:
			El navegador necesita saber el tamaño de los elementos. 
			
			Elementos sin ancho ni alto definido:

				min-content:
				Su contenido minimo y tamaño de caja será la palabra más larga.	El contenido no se desbordará.

					{width: min-content;}

				max-content:
				El contenido se muestra en una sola línea y es probable que se desborde si el contenedor no tiene el ancho suficiente.
					
					{width: max-content;}

			Espacio libre:
			Tamaño total elementos - contendor = espacio positivo o negativo

				Positivo:
				Cuando hay más espacio del necesario para mostrar todos los elementos flexibles dentro del contenedor.

			 	Negativo:
				Tamaño natural de los elementos suma más que el espacio disponible/tamaño del contenedor flex. Los elementos desbordan.
			
			*Para determinar el tamaño de los items flex debemos darnos cuenta si hay espacio positivo para distribuir o negativo para quitar.

			Tamaño por flex-direction: 
			Determinará el eje principal y si debemos calcular ancho/alto elementos con ancho/alto contenedor.
			
				row: viene por su ancho.
				column: viene por su alto.
			
			Propiedades flex:

				basis:
				Especifica el tamaño inicial del elemento flexible antes de distribuir espacio positivo.
					
					auto:
					Valor por defecto/inicial.
					Primero verifica el tamaño inicial de un elemento.

						Tamaño inicial:
						Puede tener un valor/tamaño absoluto como 200px o relativo como %, em o una palabra, etc.
						Sería la base.

						Si el elemento no tiene un tamaño definido, queda en auto.
						FLEXBOX determina que será su max-content.
						
					Ej: elementos con tamaño definido y elementos con auto
						Un elemento, que tiene un ancho explícito de 150px; su valor basis auto será 150px.
						Otro sin tamaño explicito, no tiene ancho explicito; su valor basis auto es max-content.
						En este ultimo no importa el largo de las palabras, todo el contenido se verá en una línea.
							
							.box {
						       display: flex;
						    }

						    .box :first-child {
						       width: 150px;
						    }

						    .box > * {
						       flex: 0 0 auto;
						    }
					
					valor content:
					La base flexible se toma le tamaño del contenido, incluso si hay un ancho establecido en el elemento.
					
					valor 0: 
					Ignora el tamaño del elemento ya sea auto (max-content o explicito). El espacio disponible del contenedor se repartirá proporcionalmente.

				grow:
				Espacio positivo obtenido.
				Crecimiento del elemento en relación con el resto,  cuando se distribuya el espacio libre positivo.
				Si todos tienen el mismo de distribuye uniformemente, pero se puede dar distinto.

					Combinar con basis:
						
						    .box {
						       display: flex;
						    }

						    .box > * {
						       flex: 1 1 0;
						    }

					Ej: flex: 1 1 auto
					Si los elementos no tienen tamaño determinado y basis en auto, toma el tamaño por defecto el tamaño de contenido (el ancho es la palabra más larga y el alto se ajusta a la cantidad de palabras/contenido).
					*Por la cantidad de contenido algun elemento puede quedar más grande, por más que todos tengan el mismo factor de crecimiento
					
					Ej: flex: 1 1 0
					Con basis en 0 todos los elementos quedan con el mismo tamaño porque a todos le dimos un tamaño base 0, ignora su tamaño intrinseco y extrinseco.
					Con grow 1 distribuirá proporcionalmente. 
					
					Ej: distintos valores de crecimiento desde basis 0
					Uno puede llevarse el doble o el triple del espacio disponible
					
						*calculo del navegador:
						suma los factores de crecimiento, después divide la cantidad total de espacio libre positivo en el contenedor flexible por ese número.
						A este resultado lo divide por la cantidad de elemento. 
						Así obtiene su parte cada elemento.

				shrink:
				Espacio negativo eliminado.
				Determina cuánto se encogerá el elemento flexible en relación con el resto, cuando se distribuye el espacio libre negativo.
				El navegador calcula cuando descubre que el total de los elementos son más grandes que el contenedor.
						
					Ej: un valor en 0 hace que los elementos no se reduzcan, el valor en 1 posible su reducción; si todos tienen el mismo valor se verán proporcionados.
						Vemos un ancho determinado y basis auto.
						Tambien vemos que el contenedor flex no tiene ancho, ocupará el 100% ancho de su contenedor padre.
						
						No tiene min/max-content, ni width, etc.

						    .box {
						       display: flex;
						    }
							
							.box >*	{	
								flex: 0 1 auto;        
						 		width: 200px;
							}
				
					Combinando con basis:					
					Ej: 
					Flex shrink evita que los elementos se reduzcan a 0.
					Quedan con el tamaño de min-content (el ancho de la caja será la palabra más larga)
					El item más grande toma más espacio pero los demas no desaparecen.
					Podemos hacerlo proporcional usando basis 0.		

						.box {
						    width: 500px;
						    display: flex;
						}

						.box > * {
						    flex: 1 1 auto;
						}
					
					Ej: diferentes valores de reducción
					Podemos hacer que unos elementos se reduzcan más que otros.
					
						.one {
					        flex: 1 1 auto;
					    }

					    .two {
					        flex: 1 0 auto;
					    }

					    .three {
					        flex: 2 4 auto;
						}
				
				En resumen:
				max-content lo vemos en basis, cuando el elemento no tiene tamaño definido.
				min-content lo vemos en shrink, para que el tamaño no se reduzca a 0.	
				
				Por otro lado, tenemos que controlar el tamaño del contenedor y si los elementos tiene tamaño determinado o automatico.
				
				Tamaño de basis: 
				Si está en auto pero el elemento tiene definido un tamaño explicito, toma como base el explicito.
				Si está en auto o content y el elemento no tiene uno definico, se el tamaño será el contenido.
				A basis le podemos dar una unidad de longitud o factor, si posee uno; será el tamaño del item.
				Si basis está en 0, el tamaño del elemento no se tiene en cuenta al distribuir el espacio. 
				
				Crecimiento y decrecimiento:
				Si hay espacio libre positivo (total tamaño de los elementos < contenedor), los items crecerán.
				Si hay espacio libre negativo (todos los elementos > contenedor), los items se reducirán.
				Flex-direction entra en juego para calcular anchos si es fila o altura si es columna.
				
				Justify-content:
				Podemos aplicarla cuando hay espacio libre para distribuir los elementos, sin aplicar flex basis, grow, shrink. 
				
				Margin auto:
				Para separar un grupo de elementos de otro.

		|| Tamaño de los contenedores flexibles:
			
			Elementos en multiples filas/columnas:
			No sucede automaticamente porque el valor por defecto de la propiedad flex-wrap es nowrap.
			Con el valor wrap de flex-wrap evitamos que los elementos desborden el contenedor y se acomoden en una línea nueva. 
			Tambien podemos usar fle-flow.

				{ flex-wrap: wrap; }
					o 
				{ flex-flow: row wrap; }
				{ flex-flow: column wrap; }

				Ej: filas
				Vemos elementos con tamaño explicito aplicado desde flex-basis.
				Pero un contenedor sin ancho. 

					.box {
					    display: flex;
					    flex-wrap: wrap;
					}

					.box>* {
					    flex: 1 1 160px;
					}
  
				Ej: columnas

					.box {
			       		height: 300px;
			        	display: flex;
			        	flex-direction: column;
			        	flex-wrap: wrap;
			   		}

			    	.box>* {
			        	flex: 1 1 80px;
			    	}

			*Si sobra espacio en el contenedor, el ultimo elemento lo ocupará todo; quedando desproporcionado con respecto a los demas. 		
			A menos que la cantidad de elementos coincida perfectamente con el tamaño del contenedor.
				
				Ej: cuadrícula

				    .box {
				       height: 350px;
				       width: 300px;
				       display: flex;
				       flex-direction: column;
				       flex-wrap: wrap;
				    }

				    .box>* {
				        flex: 1 1 60px;
				    }

			*Si damos altura al contenedor y tamaño base a los elementos podemos crear cuadrículas con flex.
			*Si damos ancho al contenedor, los elementos dejarán de ocupar todo el ancho de su contenedor padre.
			
			*Los valores column/row reverse solo cambian el inicio y fin: derecha a izquierda.
				
				Ej: reverse:

					.box {
				        display: flex;
				        flex-wrap: wrap;
				        flex-direction: row-reverse;
				    }
				    .box>* {
				        flex: 1 1 160px;
				    }
			
			*No se puede indicarle a un elemento que se alineen con otro en otra fila.
			Cada línea actúa como un nuevo contenedor, por eso se llena cuando hay espacio disponible.
			Esto se debe al proposito unidimensional de flexbox.
				
				Ej: grid, sobra espacio y el ultimo item no lo llena

					.box {
				        display: grid;
				        grid-template-columns: repeat(auto-fill,minmax(160px, 1fr));
				    }
				
				// a menos que borre un elemento.			
			
			*Si queremos distribución del espacio fila por fila, usamos flexbox. Si no, usamos Grid.

			Cuadrículas con flex:
			Se asigna anchos porcentuales a elementos flexible.
			Controlamos la flexibilidad usando porcentajes.

				.box {
			        width: 500px;
			        display: flex;
			        flex-wrap: wrap;
			    }
			    
			    .box>* {
			        flex: 0 0 33.3333%;
			    }
				
				o con espacios:
				
				.wrapper {
			        border: 2px dotted rgb(96, 139, 168);
			        width: 500px;
			      }

			    .box {
			        display: flex;
			        flex-wrap: wrap;
			        gap: 10px;
			    }

			    .box>* {
			        flex: 1 1 160px;
			    }

			Colapsar/esconder elementos: 
			Usamos propiedad visibility:collapse; se puede combinar con Js al momento esconder y mostrar contenido.
			Mantiene el diseño y los elementos en sus líneas, así no se representarán desprolijamente.

				<div class="box">
		          <div>One</div>
		          <div>Two</div>
		          <div class="hide">Three
		              <br>has
		              <br>extra
		              <br>text
		          </div>
		        </div>

				.box {
	            	display: flex;
	         	}

	          	.box>* {
	            	flex: 1 1 200px;
	          	}
	          
	          	.hide {
	            	visibility: collapse;
	          	}
			
			Ej: elemento escondido con varias filas
				Si al elemento escondido le sacamos la propiedad visibility, el diseño se rompe; se distribuye el espacio y los demás elementos cambian de tamaño, el contenedor puede cambiar de tamaño si no lo tiene definido.
				
				.box {
		            display: flex;
		            flex-wrap: wrap;
		        }
		        
		        .box>* {
		            flex: 1 1 auto;
		        }
		        
		        .hide {
		            visibility: collapse;
		        }

				<div class="box">
	                <div>One</div>
	                <div>Add more text to this box to make it grow</div>
	        		<div class="hide">Three
	              		<br>has
	              		<br>extra
	              		<br>text
	         		 </div>
	          		<div>Four</div>
	          		<div>Five</div>
	          		<div>Six</div>
	          		<div>Seven</div>
	          		<div>Eight</div>
	          	</div>
			
			*Cuando se vuelve a mostrar el elemento causa problemas en el diseño, puede requerir un replanteamiento de la estructura, por ejemplo, colocar cada fila en un contenedor flexible separado para que no puedan cambiar filas.
			
			visibility: hidden y display none:
			La diferencia con display: none es que este lo elimina del formateo de la página, en cambio el otro lo ocuta pero se puede usar.			
			*Chrome y Safari tratan a collapse como hidden.

		|| Usos tipico:
			El fuerte de flexbox es su capacidad de alineación y su gran compatibilidad con navegadores antiguos y modernos.

			Navegación:

				// Dependiendo del HTML o del diseño, seleccionamos uno u otros elementos y agregamos otras capacidades.
					Lo ideal es que cada selector tenga un nombre dado con una clase así es más facil el mantenimiento.	
						
						<nav>
					 		<ul>
					   			<li><a href="#">Page 1</a></li>
					    		<li><a href="#">Page 2</a></li>
							</ul>
						</nav>

						nav ul {
						  display: flex;
						  justify-content: space-between;
						}

						
						o //Diferente espaciado en los elementos.

						nav ul {
						  display: flex;
						}

						nav li {
						  flex: auto ;
						}


						o // Barra de navegación fija para pantallas grandes.

						nav {
						  position: sticky;
						  top: 0;
						  z-index: 99;
						}

				        nav ul {
				          display: flex;
				          flex-flow: row wrap;
				          justify-content: space-between;
				        }

				        nav ul li {
				          flex: 1fr;
				        }		

				Agrupar y empujar elementos a un lado:
					
					<div class="box">
						<div>Three</div>
					  	<div class="push">Four</div>
					  	<div>Five</div>
					</div>	

					.box {
					  display: flex;
					}
					.push {
					    margin-left: auto;
					}
						
						o
				
					nav ul {
					  display: flex;
					  margin: 0;
					}

					.push-right {
					  margin-left: auto;
					}

					 	0

					nav ul {
					  display: flex;
					  margin: 0 -10px;
					}

					nav li {
					  margin: 0 10px;
					}

					.push-right {
					  margin-left: auto;
					}
			
			Diseño de carta:

				Con footer abajo:
				Necesitamos que el footer se pegue a la parte inferior de la carta, el diseño de bloque interno de los elementos flexibles no puede lograrlo; los elementos se muestran seguido.
				Hacemos que el contenido/elemento antes del footer crezca.	
				
					.card {
					  display: flex;
					  flex-direction: column;
					}

					.card .content {
					  flex: 1 1 auto;
					}
				
					<div class="cards">

					  <div class="card">
					    <div class="content">
					      <p>This card doesn't have much content.</p>
					    </div>
					  <footer>Card footer</footer>
					
						//... más cartas

					</div>

				Con titulos y más elementos:

					<div class="wrapper">
			        	<div class="card">
			            	<h3>News item title</h3>
			            	<div class="date">1 Nov 2017</div>
			            	<p>This is the content of my news item. Very newsworthy.</p>
			        	</div>
					</div>
					
					.card {
            			display: flex;
            			flex-direction: column;
        			}
				
			Centrar item:

				.box {
				  display: flex;
				  align-items: center;
				  justify-content: center;
				}

				.box div {
				  width: 100px;
				  height: 100px;
				}		
			
			Media object:
			Imagen u otro elemento a un lado y texto a la derecha.
			
				Ej: tenemos un contenedor flex con dos elementos, la alineación en el eje transversal es flex-start para que se coloquen arriba de todo.
					La imágen o su contenedor tiene padding a los cuatro lados para que el texto se acomode bien.
					Además, agregamos flex: 1; para que crezca hasta su 100% (seleccionamos la imagen con otra regla) y el texto no ocupe casi todo el espacio del contenedor.

					<div class="media">
					  <div class="image"><img src="MDN.svg" alt="MDN logo"></div>
					    <div class="content">This is the content of my media object.</div>
					</div>

					.media {
					  display: flex;
					  align-items: flex-start;
					}

					.media .content {
					  flex: 1;
					  padding: 10px;
					}

					.imagen img {
					   ancho máximo: 100px;
					}

					// si queremos que crezcan y se reduzcan en proporción:

						.media .content {
						  flex: 1;
						  padding: 10px;
						}

						.image {
						  flex: 1;
						}

			 Controles de formularios:
			Requieren muchos elementos de html, debemos alinearlos.
					
				<form class="example">
					<div class="wrapper">
						<input type="text" id="text">
						<input type="submit" value="Send">
					</div>
				</form>
				
				.wrapper {
		  			display: flex;
				}

				.wrapper input[type="text"] {
		  			flex: 1 1 auto;
				}

				Tenemos los botones imput y buttom en un contenedor flex. Despues hacemos que imput crezca, mientras que buttom no. El campo crecerá a medida que cambie el tamaño de la ventana.
				
				Agregamos otro botón:

					.wrapper {
			  			display: flex;

					}

					.wrapper input[type="text"] {
			  			flex: 1 1 auto;
					}

					<form class="example">
					  <div class="wrapper">
					    <label for="text">Label</label>
					    <input type="text" id="text">
					    <input type="submit" value="Send">
					  </div>
					</form>
					-->
				</code>
				
				Ponemos un label o un icono a la izquierda, ahora el campo de entrada de datos flexible tiene menos espacio.
			
		|| Dar compatibilidad:
			Para navegadores muy antiguos debemos incluir los prefijos en cada regla.

				.wrapper {
				  display: -webkit-box;
				  display: -webkit-flex;
				  display: -ms-flexbox;
				  display: flex;
				}

			*autoprefixer es un sitio dónde podemos ver los prefijos que necesitamos para las versiones antiguas de los navegadores.
			
		    fallbacks:
			Flexbox ignorará las siguientes propiedades por eso podemos usarlas en los elementos flex para dar compatibilidad a navegadores antiguos que no admiten flex. 
			Con ellas logramos diseños parecidos. Los navegadores modernos sobreescribirán las propiedades antiguos y aplicará las modernas.

				float y clear: 
				Cuando aplicamos flex a un flotante, estos dejan de tener efecto.
				Se convierten en elementos flexibles y adquieren la misma proporción, algo que no pasa en float.

					.box {
					  display: flex;
					}

					.item {
					  float: left;
					  width: 150px;
					  flex: 1;
					}
   
				display inline-block:
				Pasa lo mismo, si eliminamos la propiedad flex, vemos las diferencias. 
				Presenta espacios en blanco.
					
					.box {
					  display: flex;
					}

					.item {
					  display: inline-block;
					  width: 150px;
					  flex: 1;
					}					

				display table-:
				Funciona hasta I.E, crea elementos anomimos para representar un diseño de columnas y centrado.
				Pero no se pueden diseñar. Si eliminamos la propiedad flex, vemos que se crean columnas parecidas.

					.box {
					  display: flex;
					}

					.item {
					  display: table-cell;
					  width: 150px;
					  flex: 1;
					}

      			vertical-align:
				Se puede usar en display: table-cell y display: inline-block.
				Flexbox y los navegadores modernos sobreescribirán esta propiedad y podemos usar justify-content o align-content.

					.box {
					  display: flex;
					}

					.item {
					  display: inline-block;
					  vertical-align: top;
					  width: 150px;
					  flex: 1;
					}

				Queries:
				Podemos detectar si hay compatibilidad con flex

					@supports (display: flex) {
					   //code for supporting browsers
					}
				
					o para los que admiten el prefijo antiguo de flexbox

					@supports (display: flex) or (display: -webkit-box) {
					   //code for supporting browsers 
					}


	|| GRID
		La cuadrícula se forma con un conjunto de líneas horizontales y verticales, los elementos se pueden colocar dentro de ellas.
		Podemos hacerlas de tamaño fijo (px) para que los elemtos se adapten al diseño. 
		O hacerlas flexibles (1fr) para que el diseño se adapte a los elementos.
			
		|| Contenedor:
			Solo los hijos directos serán grid items. Display flex por si solo, creará varias una columna con todos los elementos dispuestos uno debajo de otro.		
			Las pistas le dan forma final de cuadrícula, se crean con grid-templete-rows/columns.
			Los elementos que no son o no pueden ser colocados en las pistas creadas por nosotros, se colocarán automaticamente en las pistas implicitas que creará el navegador.
			El tamaño de las pistas explicitas serán los valores que esten en grid-templete-columns/rows.
			El tamaño de las pistas implicitas será su contenido o usar grid-auto-rows/columns.
				
				.wrapper {
				  display: grid;
				  grid-template-columns: repeat(3, 1fr);
				  grid-auto-rows: 200px;
				}

			Las unidades flexibles se usan para que el diseño se adapte al ancho de la ventana del navegador, las pistas o elementos crecen y se reducen segun el espacio disponible.
			Podemos dar diferentes valores para que una parte del diseño se vea más grande u ocupe más espacio disponible que otras partes del sitio. 
			Tambien podemos mezclar los valores inflexibles/absolutos con los flexibles para elementos que tengan que ser mostrados completamente y para elementos que puedan reducirse.
			Podemos usar las funciones minmax() para dar un tamaño flexible entre un mínimo y máximo. 
				
				.wrapper {
				  display: grid;
				  grid-template-columns: repeat(3, 1fr);
				  grid-auto-rows: minmax(100px, auto);
				}
			
			Las líneas de grid se definen después de las pistas (a su vez crean celdas), su numeración depende de la dirección de escritura.
			Con grid-column o grid-row start/end, los números de las líneas serán los sus valores.
			Para colocarlos en las áreas usamos grid-template-areas para crear el diagrama con los nombres de las areas que tenemos que configurar con la propiedad grid-area.
			El diagrama de las areas debe ser rectángular
			Podemos superponer los elementos usando las líneas o usando z-index.
			
				.box1 {
				  grid-column-start: 1;
				  grid-column-end: 4;
				  grid-row-start: 1;
				  grid-row-end: 3;
				  z-index: 2;
				}

		|| Flexbox vs Grid:
			Flex funciona desde el contenido que toma el espacio del contenedor, además de las capacidades de alineación y espaciado. 
			Grid prioriza el diseño y a partir de este colocamos a los elementos. Si creamos pistas que se adaptan al contenido, los elementos se acomodan en línea nueva.

			Alineación:
			El eje principal es la dirección en línea (texto) y el eje secundario es la dirección en bloque (cajas).
			Podemos usar algunas propiedades de box-aligment que valen tanto para flex y grid.

				.wrapper {
				  display: grid;
				  grid-template-columns: repeat(3, 1fr);
				  align-items: end;
				  grid-auto-rows: 200px;
				}
				.box1 {
				  align-self: stretch;
				}
				.box2 {
				  align-self: start;
				}
			
			Unidades flexibles:
			La unidad fr, cuando se combina con la función minmax(), puede brindarnos un comportamiento muy similar a las propiedades flex en flexbox.
			Hay una diferencia entre la forma en que los dos diseños funcionan de manera receptiva, como hay diferencia en la forma de diseño y representación.
			Flexbox puede acomodar todos los elementos en una fila siempre que haya espacio.
			Mientras que en Grid siempre van a estar las mismas pistas que definimos aunque más chicas o grandes.

			Autocompletar y autoajustar cuadrícula:
			Para las filas o columnas podemos usar el valor auto-fill y auto-fit para lograr un efecto responsivo como en flexbox en la función repeat.
				
				Ej: Con auto-fill creará tantas columnas de 200 px como entren en el contenedor.
					
					.wrapper {
					  display: grid;
					  grid-template-columns: repeat(auto-fill, 200px);
					}

					// Puede quedar espacio sin ocupar en el contenedor.
				
				Ej: Con auto-fit y minmax() repartirá el espacio del contenedor entre el mínimo y el máximo.
					Tendremos filas y columnas variables y responsivas.

					.wrapper {
					  display: grid;
					  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
					}

					// Los elementos ocupan todo el espacio del contenedor.

		|| Grid y position absolute:
			Cuando un contenedor grid es bloque contenedor de un elemento posicionado
			Para que el contenedor de grid se bloque contenedor de un elemento, debemos agregarle la propiedad position: relative.
			Así es como funciona para cualquier otro elemento padre cuando necesitemos un elemento absoluto.
			Ahora podemos mover el elemento en todo el area del bloque contenedor/cuadrícula.
				
				wrapper {
				  display: grid;
				  grid-template-columns: repeat(4, 1fr);
				  grid-auto-rows: 200px;
				  gap: 20px;
				  position: relative;
				}

				.box3 {
				  grid-column-start: 2;
				  grid-column-end: 4;
				  grid-row-start: 1;
				  grid-row-end: 3;
				  position: absolute;
				  top: 40px;
				  left: 40px;
				}

				// Estaba posicionado en esas líneas, salió del flujo y cierra ese lugar; se ubica a 40px desde top y left.		
			
			*Una cuadrícula que es padre de un elemento absoluto pero que no tiene position: relative no puede contener a ningun elemento.
			El bloque contenedor pasa a ser la ventana gráfica si no hay otro.	
			Si eliminamos position: relative del contenedor vemos este efecto.
			
			Grid item como contenedor de un elemento absoluto:
				
				<div class="wrapper">
					<div class="box2">Two</div>
				 	<div class="box3">
				    	Three
				 	
				  		<div class="abspos"> 
				 			subelement of three
				    	</div>

					</div>
				</div>
				
				.wrapper {
				  display: grid;
				  grid-template-columns: repeat(4, 1fr);
				  grid-auto-rows: 200px;
				  gap: 20px;
				}

				.box3 {
				  grid-column-start: 2;
				  grid-column-end: 4;
				  grid-row-start: 1;
				  grid-row-end: 3;
				  position: relative;
				}

				.abspos {
				  position: absolute;
				  top: 40px;
				  left: 40px;
				  background-color: rgba(255, 255, 255, 0.5);
				  border: 1px solid rgba(0, 0, 0, 0.5);
				  color: #000;
				  padding: 10px;
				}
			
		|| display: contents:
			Los elementos secundarios de un item de cuadrícula no pertenecen a ella, su comportamiento es de elementos de bloque comunes.
			Cuando activamos display: contents al elemento padre, los hijos se disponen en cuadrícula.
				
				<div class="wrapper">
				  <div class="box box1">
				    <div class="nested">a</div>
				    <div class="nested">b</div>
				    <div class="nested">c</div>
				  </div>
				</div>
			
				.wrapper {
			  		display: grid;
			  		grid-template-columns: repeat(3, 1fr);
			  		grid-auto-rows: minmax(100px, auto);
				}

				.box1 {
			  		grid-column-start: 1;
			  		grid-column-end: 4;
			  		display: contents;
				}
			
		|| Colocación automatica:
			Si no los colocamos en la cuadrícula de ninguna manera, se distribuirán de acuerdo con las reglas de colocación automática, un elemento en cada una de las celdas, uno despues de otro. 		
			
				.wrapper {
				  display: grid;
				  grid-template-columns: repeat(3, 1fr);
				  grid-template-rows: repeat(3, 100px);
				}
				
				// tenemos 3 columnas y 3 filas que forman 9 celdas para colocar elementos. 
					Este diseño creo 4 líneas en cada dimension (horizontal y vertical).
					Y tambien, si tenemos menos de 9 elementos sobrarán lugares. 
			
		|| Espacios vacios:
			Es otra caracteristica de grid, podemos dejar espacios sin usar margenes.
			Con la ubicación en línea tendríamos que evitar las líneas que definen el área que deseemos que este vacia.
			Con grid-template-areas usamos un punto cuando hacemos el diagrama.
			
			Si un elemento ocupa todo una fila o columna no hace falta el valor de grid-column o grid-row end.
				
				.box1 {
				  grid-column-start: 1;
				  grid-row-start: 1;
				  grid-row-end: 4;
				}
				
				.box3 {
				  grid-column-start: 2;
				  grid-row-start: 1;
				}
				
				o

				.box1 {
				  grid-column: 1;
				  grid-row: 1 / 4;
				}

				.box3 {
				  grid-column: 2;
				  grid-row: 1;
				}

			Con el diagrama de grid-template-areas ponemos el nombre de las areas las veces que necesitamos.
			
			Con grid-area ademas de dar un nombre a los elementos, podemos ubicarlos en las líneas
			Su orden:

		    	grid-row-start
    			grid-column-start
    			grid-row-end
    			grid-column-end
			
				.box1 {
				  grid-area: 1 / 1 / 4 / 2;
				}

				.box3 {
				  grid-area: 1 / 2 / 2 / 3;
				}
				
				// El orden está inspirado en el flujo lógico: 
					
					block-start
					inline-start
					block-end
					inline-end
			
		|| Líneas negativas/reversa:
			En modo de escritura de izquierda a derecha, para columnas se empiezan a numerar desde la derecha, -1 es la primera, sigue -2, etc.
			Para filas se enumeran desde abajo hacia arriba -1, -2.
			Quiere decir que el posicionamiento en dirección/orden se cuenta de esa manera.
				
				.box4 {
				  grid-column-start: -2;
				  grid-column-end: -4;
				  grid-row-start: -3;
				  grid-row-end: -4;
				}
			
			Podemos estirar un elemento a lo largo del contenedor:
				
				.item {
				  grid-column: 1 / -1;
				}

		|| Espacios:
			Las propiedades column-gap, row-gap y gap no agregan espacio, sino que lo toman.
			Si las filas y columnas nos quedan más pequeñas de lo que deseamos, aumentamos su tamaño en grid-template-columns/rows
				
				.wrapper {
				  display: grid;
				  grid-template-columns: repeat(3, 1fr);
				  grid-template-rows: repeat(3, 100px);
				  column-gap: 20px;
				  row-gap: 1em;
				}
			
		|| Ubicación con el valor span:
			Podemos especificar una línea de inicio y luego el número de pistas que desea que abarque el área.
				
				.box1 {
				  grid-column: 1;
				  grid-row: 1 / span 3;
				}

				// Ej: Si 4 filas, empieza desde uno y despues toma 3; expandiendose hasta el final.
					En la columna no tenemos el valor final, toma toda la columa 1.
		
		|| Nombrar un área
			Con grid-area le damos un nombre y con grid-template-area le damos ubicación, haciendo una especie de diagrama con los nombres.
			Las áreas principales de una página puede ser:

		     	un encabezado
		    	un pie de página
		    	una barra lateral
		     	el contenido principal

		    Podemos dejar una celda vacia usando un punto en el diseño de grid-template-areas	
			Cada fila de grid-template-areas se crea con comillas dobles al inicio y al final.
			En al ultima fila colocar punto y coma para cerrar la propiedad.
			Siempre que haya un espacio entre varios puntos, formará las celdas.
			Para ordenar el diseño (solo en la propiedad) ubicamos los nombre en línea.
			Para expandir elementos en las celdas, usamos varias veces su nombre; la forma debe ser rectángular. Así creamos areas más grandes.

				.wrapper {
				  display: grid;
				  grid-template-columns: repeat(9, 1fr);
				  grid-auto-rows: minmax(100px, auto);
				  grid-template-areas:
				    "hd hd hd hd   hd   hd   hd   hd   hd"
				    "sd sd sd main main main main main main"
				    ".  .  .  ft   ft   ft   ft   ft   ft";
				}
				
				<div class="wrapper">
				  <div class="header">Header</div>
				  <div class="sidebar">Sidebar</div>
				  <div class="content">Content</div>
				  <div class="footer">Footer</div>
				</div>
			
		|| Redifinir todo el diseño con queries
			Empezamos con un diseño de columna flexible pero muy grande, hasta los 500px del segundo punto de interrupción.
			Despues pasamos a un diseño de menos filas pero más ancho para que entre todo el contenido.

				.wrapper {
				  display: grid;
				  grid-auto-rows: minmax(100px, auto);
				  grid-template-columns: 1fr;
				  grid-template-areas:
				    "hd"
				    "main"
				    "sd"
				    "ft";
				}

				@media (min-width: 500px) {
				  .wrapper {
				    grid-template-columns: repeat(9, 1fr);
				    grid-template-areas:
				      "hd hd hd hd   hd   hd   hd   hd   hd"
				      "sd sd sd main main main main main main"
				      "sd sd sd  ft  ft   ft   ft   ft   ft";
				  }
				}

				@media (min-width: 700px) {
				  .wrapper {
				    grid-template-areas:
				      "hd hd hd   hd   hd   hd   hd   hd hd"
				      "sd sd main main main main main ft ft";
				  }
				}
		
		|| Componentes ui:
			Grid puede ser util para crear elementos pequeños.

			media object:
			Se compone de un elementos multimedia (img, video, svg, etc) y de texto.
			Podemos crear dos columnas de tamaño fijo, variable, combinado, uno responsivo y otro no
				
				* {
				  box-sizing: border-box;
				}

				.media {
				  border: 2px solid #f76707;
				  border-radius: 5px;
				  background-color: #fff4e6;
				  max-width: 400px;
				  display: grid;
				  grid-template-columns: 1fr 3fr;
				  grid-template-areas: "img content";
				  margin-bottom: 1em;
				}

				.media .image {
				  grid-area: img;
				  background-color: #ffd8a8;
				}

				.media .text {
				  grid-area: content;
				  padding: 10px;
				}

				// al reves:

				.media.flipped {
				  grid-template-columns: 3fr 1fr;
				  grid-template-areas: "content img";
				}



















/*