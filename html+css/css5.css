/*
	|| NORMAL FLOW

		Los elementos en bloque tienen dos direcciones: block-direction (como aparecen las cajas) y inline-direction (direción hacia donde fluye el contenido).	
		La propiedad writing-mode determina las dirección de los elementos en los metodos de diseño.
		La propiedad display cambia los metodos de diseño.
		Las direction y text-direction son parecidas a writing-mode.		

		Los contexto de formato determina el comportamiento de los elementos en bloque y en línea:
			
			en bloque:
			Los margenes verticales crean una separación, si aplicamos margin: 0; elimina los margen en los cuatro lados, se juntarán las cajas.
			El contenido de los elementos en bloque ocupará todo el espacio que haya en el contenedor del bloque, hacia donde fluya la dirección de este.
			Aparecerán uno debajo de otro, incluso si para dos elementos determinamos un ancho para que entren los dos.
			
			en línea:
			Se muestran uno tras otro en la dirección de contenido que disponga el modo de escritura que se esté usando.
			Solo podemos aplicar propiedades horizontales del model box (izq y der: width (content área), padding, margin)
			Solo le podemos dar altura si cambiamos el tamaño de fuente para su contenido.
			
			*Los dos tipos de elementos tienen un principio y final que es importante para las propiedades lógicas.	

			Colapso de margen:
			Cuando los margenes top y bottom se tocan, que uno solo: el más grande. Aunque hay más casos.
			
			Elementos de reemplazo (img, video, etc):
			No cambian su orientación/visualización por el modo de escritura.

		Display: define los tipos de visualización 

			exterior:
			Determina como se comporta la caja con respecto a las demás cajas dentro de ese mismo contexto de formato.
			
			interior:
			Determina como se comportan las cajas/elementos dentro de este elemento.
		
		Propiedades lógicas:
		block-size, inline-size y las demás se adaptan bien a los valores de display y writing-mode.

		Elementos del HTML:
		El elemento HTML crea el contexto de diseño/formato inicial para que los elementos esten dentro de la página.	
		Seguirán el comportamiento del normal flow, a menos que con algunas propiedades o algunos valores de display podamos sacarlos de este contexto para crear otros con distintos comportamientos.

			In flow:
			Elementos que pertenecen al contexto inicial creado por la etiqueta HTML.

			Out flow:
			Elementos que pueden salir del flujo con float, position fixed y absolute, etc.
			Podrán superponerse con los elementos que están en el contexto inicial.
			
			BFC (block formatting context):
			Hay propiedades que pueden crear estos elementos especiales que son mini html que estan fuera del principal que exteriormente sigue un comportamiento de bloque.
			Por ejemplo, un float o los item de grid o flex son bfc.

		Desbordamiento/overflow:
		Hay más contenido del que cabe en un contenedor de tamaño restringuido.
		En el flujo normal, darle a un elemento una altura y un ancho fijos genera un desbordamiento.
		
		Por defecto la propiedad overflow está en visible.
		Podemos ocultarlo (hidden) o poner barras horizontal y vertical(scroll) y auto (pone barras cuando son necesarias).
		overflow es abreviada de overflow-x y overflow-y.
		Todas estas crean un nuevo BFC.

		Pero tambien hay otras propiedades que se adaptan al texto o al caja para que no se desborde.
		Como white-space, overflow-wrap, word-break, width: fit-content, width: max-content.
		
		*Estas propiedades no hacen falta en un texto no dinamico/contralado usuario. 
		 Si en una caja definimos ancho pero no alto y la palabra más larga no supera el ancho de la caja, la altura de la caja se ajusta automaticamente al texto;
			
			Ej: Para un parrafo en una caja:
				
				<div class="box">
    			<p>One November night in the year 1782, so the story runs, two brothers sat over their winter fire in the little French town of Annonay, watching the grey smoke-wreaths from the hearth curl up the wide chimney.</p>
				</div>

				.box {
				    width: 300px;
				    border: 5px solid rebeccapurple;
				    padding: 10px;
				}

				.box p {
				    
				    // no harián falta //

				    white-space: nowrap;
				    text-overflow: ellipsis;
				    overflow: hidden;
				}

		Para propiedades lógicas:
		Son como block-size e inline-size que reemplazan a height y width.

			overflow-block:
			Reemplaza a la propiedad vertical, overflow-y

			overflow-inline:
			reemplaza a la propiedad overflow-x.
		
		*Todavía no están implementadas, se deben usar las físicas y ajustar el modo de escritura.
		
		Propiedades para los ejes:
			
			En bloque:
			block-overflow, no está aprobada.

			En línea:
			text-overflow: siempre evitará el desbordamiento. Para que funcione necesitamos algunos valores de las propiedades white-space y overflow.					
								
				.box p {
				    white-space: nowrap;
				    text-overflow: ellipsis;
				    overflow: hidden;
				}

			Todos los valores cortan el texto:
				
				clip: Puede ocurrir en medio de un carácter.

				ellipsis: Antes agrega puntos suspensivos.
				
				text-overflow: "-"; agregará un guión.

				text-overflow: ""; impide que corte el texto en medio de una palabra.
		
		Modelo de formato visual:
		Describe como los navegadores leen el DOM (árbol del documento) y lo muestran para los medios visuales (continuous media) una página, audio, video; y medios páginados (paged media) como puede ser un pdf para imprimir, un libro, etc.
		Los elementos del DOM o del documento (web, pdf, etc) tienen un orden de renderizado:

			1. Las cajas de CSS y su tamaño
			2. Su posicionamiento en normal flow, float y position absolute.
			3. Relaciones entre elementos en el árbol del documento.
			4. Información externa (tamaño del viewport, tamaño de imagenes).

		Cajas anonimas
		Son elementos que no podemos diseñar con CSS porque no tienen etiqueta de HTML.
			
			Casos:
			1° Hay un elemento de HTML para usar en una caja. Por ejemplo, cuando declaras display flex en un contenedor/elemento principal y hay texto que no está encerrado en un parrafo. El arbol de cajas, creará una caja anonima para contener ese texto. Se comportará como un elemento flexible pero no se puede diseñar como una caja normal porque no podemos llamar al contenido suelto.
			2° Lo mismo puede suceder cuando en un div hay contenido de texto suelto sin el elemento parrfo. Y lo mismo pasa con otros metodos de diseño.
			2° Tambien sucede con las cajas en línea cuando hay uno de estos elementos vacio.	


	|| FLEX
		Dispone los elementos sobre un eje vertical u horizontal, por eso es unidimensional.

		Dos ejes:
		El eje principal está definido por flex-direction, y el eje transversal corre en perpendicular (90°) al primero.
		
			Valores de flex-direction:

				row: 
				El eje principal corre en la dirección en línea/texto/contenido. 
				Los items se ordenan en línea, uno al lado de otro.
					
					Su eje secundario correrá en dirección de bloque.

				column: 
				Corre en dirección de bloque/elementos. 
				Los items se ordenan en columna, uno debajo de otro.
					
					El eje secundario correrá en dirección en línea.
				
				column-reverse/row-reverse: dirección contraria.
		
		writing-mode:
		Determina dónde empiezan o terminan los elementos, start/end.

		Valores por defecto:

			Flex-direction: row;
			Los items no crecen pero si se reducen
			Los items crecen en el eje transversal para contener todo el contenido
			flex-basis: auto;
			flex-wrap: nowrap;

		Valores auto / 0:

			auto:
			indica que los elementos toman el tamaño establecido en ellos mismo o si no tienen, su contenido determinará su tamaño.
			
			0: 
			indica que va a ignorar el tamaño "auto" de los elementos (por contenido o por su ancho definido) así comparte todo el espacio disponible (del contenedor) proporcionalmente.

		flex-wrap: wrap;
		Acomoda los elementos en multiples líneas cuando no hay espacio en una sola.
		
		flex-flow: 
		Es abreviada para flex-directión y flex-wrap.
			
			{flex-flow: row wrap;}

		Propiedades para los items:
		Usan el espacio disponible del contenedor flex.
		Tamaño horizonal/vertical del contenedor menos el tamaño de los elementos.
		Si sobra espacio, podemos distribuirlo entre los elementos.

			flex-grow: 
			Agrega/toma espacio del disponible para agrandar elementos.

			flex-shrink:
			Quita espacio para reducir elementos. 

			flex-basis:
			Define el tamaño de los elementos para crecer o reducirse.

				auto: valor por defecto.
				Los elementos toman el tamaño establecido en ellos mismo o si no tienen, su contenido determinará su tamaño.
			
				0: 
				Indica que va a ignorar el tamaño "auto" de los elementos (por contenido o por su ancho definido) así comparte todo el espacio disponible (del contenedor) proporcionalmente.
			
			Flex:
			Abreviada de grow, shink, basis; en este orden.

				Configuraciones:

					flex: 1 o flex: 2
					Es como si usará flex: 1 1 0, o flex: 2 1 0; para los valores flex grow (crecimiento), shrink (reducción) o basis (tamaño). 
					Los elementos pueden crecer o reducirse a partir de una base flexible de 0 (espacio proporcional).

					flex: initial
					Resetea a los valores iniciales que son flex: 0 1, cero para crecimiento, uno para reducción y auto para la base de los valores anteriores.
					
					flex: auto
					Es flex: 1 1 auto, los elementos pueden crecer y reducirse a partir de su tamaño determinado.

					flex: none 
					Es flex: 0 0 auto, se distribuyen en el contenedor utilizando el tamaño mismo de los elementos, debido al valor auto.
			
			Alinear elementos:
				
				justify-content:
				Alinea elementos en el eje principal.

				align-items:
				Para alinear elementos en el eje secundario
			
		Writting mode:
		Flexbox se adapta a los modos de escritura, se usa para cuestiones creativas de diseño ya que estamos en CSSS, no se usa para cambiar el idioma de un documento completo. 
		El idioma se trata desde HTML con los atributos dir y lang para indicar la dirección de texto y su idioma.

		Flexbox y otros metodos:

			Float y cleaner:
			Si el contenedor de un float se convierte flex, no se aplicarán estás propiedades.
			
			Grid:
			Si un elemento flexible se convierte en un elemento de cuadrícula, se ignorarán las propiedades flexibles que se hayan asignado a los elementos secundarios.
			O reemplazar un cuadrícula con flex, para navegadores antiguos.		
				
				   	<div class="box">
				       <div>One</div>
				       <div>Two</div>
				       <div>Three</div>
				    </div>
					
					.box {
			          display: flex;
			          flex-wrap: wrap;
			        }

			        .box>* {
			          flex: 1 1 200px;
			        }
					
					.box {
				        display: grid;
				        grid-template-columns: repeat(auto-fill, minmax(200px, auto));
				    }

				*creamos el mismo diseño en flex y en grid

			Propiedad display: contents
			Si un elemento flexible tiene dos elementos anidados, que normalmente no participarían en el diseño flexible.
			Elimina el diseño o estilo aplicado a a los subitems y tambien el estilo de bloque por fuera que le da el contenedor.

				.box {
		            display: flex;
		        }

		        .nested {
		            background-color: orange;
		            display: contents;
		        }

		Alineaciones:
		Dejan el espacio en el eje principal o secundario.
		Segun el flex-direction, los ejes van cambian; el espacio estará en eje de bloque o en el eje de línea. 
			
			Propiedades:

			justify-content: 
			Controla la alineación de todos los elementos en el eje principal (main).</li>
			
			align-items: 
			Controla la alineación de todos los elementos en el eje secundario (cross).</li>
			
			align-self: Controla la alineación de un elemento en el eje secundario.</li>
			
			align-content: 
			Controla el espacio entre las líneas del eje secundario.</li>
			
			gap, column-gap, and row-gap: 
			Crean espacios entre elementos flexibles.
			
			Valores:
				
				justify-content: En eje principal
				
					flex-start
					flex-end
					center
					space-between
					space-around
					space-evenly

				align-items: En eje secundario
					
					flex-start
					flex-end
					center
					stretch
					baseline
				
				align-content: En eje secundario

					flex-start
					flex-end
					center
					space-between
					space-around
					stretch
					space-evenly
			
		Margenes automaticos:
		Para separar un grupo de elementos alineados en un contenedor.
			
			<div class="box">
			  <div>One</div>
			  <div>Two</div>
			  <div>Three</div>
			  <div class="push">Four</div>
			  <div>Five</div>
			</div>	

			.box {
			  display: flex;
			}
			.push {
			    margin-left: auto;
			}
		

		Gaps: espacios entre los elementos

			.box {
			  display: flex;
			  flex-wrap: wrap;
			  row-gap: 10px;
			  column-gap: 2em;
			}

			.box > * {
			  flex: 1;
			}


	|| GRID

		Alineación:
		El eje principal es la dirección en línea (texto) y el eje secundario es la dirección en bloque (cajas).


























 */