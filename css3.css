/*
	|| NORMAL FLOW
		Disponemos de elementos de bloque que aparecen uno debajo de otro y 
		de elementos de línea que aparecen uno al lado de otro.
			
			bloque:
			Va a ocupar el 100% del ancho de su elemento padre.
			
			línea:
			Tiene su ancho y alto determinado por su contenido, a menos que cambie a display: inline-block;
		
		*Es una buena practica comenzar el documento con el flujo normal y despues hacer las modificaciones.
		Al contenido de una caja se le añade padding (relleno), border y margin. 
		El modelo de caja más facil de aplicar es el que se usa con box-sizing: border-box en el cual las propiedades anteriores no afectan a la caja cambiando su anchura y altura dado.
		Si dos elementos adyacentes tienen margen aplicado, se impondrá el más grande debido al colapso de margen.


	|| FLEX

		Contenedor y elementos flex:

			<div class="wrapper">
              <div class="box1">One</div>
              <div class="box2">Two</div>
              <div class="box3">Three</div>
            </div>
            
            .wrapper {
              display: flex;
            }

            .wrapper > div { 
              flex: 1;   // selecciona todos los descendientes del contenedor.
            }
		
		Propiedades para el contenedor:
			display: flex
			flex-direction y flex-wrap = flex-flow
			align-items
			justify-content

		Propiedades para los elementos:
			flex
			align-self
			justify-self
			order
		
		Anidación:
		
		El articulo 3 tiene 3 divs tomamos el 1° para transformarlo en contenedor de nuestros botones.

			article:nth-of-type(3) div:first-child {
			  flex: 1 100px;
			  display: flex;
			  flex-flow: row wrap;
			  align-items: center;
			  justify-content: space-around;
			}
	
		botones con flex: 1 auto; ocuparán el espacio que puedan cuando reducimos el ancho de la ventana del navegador y cuando no puedan saltarán a la nueva línea.
			
			button {
			  flex: 1 auto;
			  margin: 5px;
			  font-size: 18px;
			  line-height: 1.5;
			}


	|| GRID
		
		Contenedor y elementos:
			
			<div class="wrapper">
              <div class="box1">One</div>
              <div class="box2">Two</div>
              <div class="box3">Three</div>
              <div class="box4">Four</div>
            </div>
            
            .wrapper {
              display: grid;
              grid-template-columns: 1fr 1fr 1fr;
              grid-template-rows: 100px 100px;
              gap: 10px;
            }

            .box1 {
              grid-column: 2 / 4;
              grid-row: 1;
            }		

		Propiedades para el contenedor:
			display: grid
			grid-template-rows
			grid-template-columns
			grid-column-gap
			grid-row-gap
			gap
			grid-auto-rows      //tamaño implícito
			grid-auto-columns
		
		Propiedades para los elementos:
			grid-column-start/end
			grid-row-start/end
			grid-column
			grid-row        //ubicación 
			grid-area
			grid-template-areas
			grid-template-rows
			grid-template-columns

		Repetir cuadrícula y fila o columna implicita:
		El primer valor será para la cantidad y el segundo valor será para el tamaño, separados por una coma.
		Podemos determinar tamaño de fila o columna implicita con grid-auto-rows/columns.

			.container {
              display: grid;
              grid-template-columns: repeat(3, 1fr);
			  grid-auto-rows: 100px;
              gap: 20px;
            }
		
		Contenido min y max:
		El contenido mínimo/max deben coincidir al menos para evitar desbordamiento.			
		
		minmax(): 
		El primer valor es para altura (row) o anchura (column) mínima y el segundo determina el valor máximo.
			
			.container {
              display: grid;
              grid-template-columns: repeat(3, 1fr);
              grid-auto-rows: minmax(100px, auto);
              gap: 20px;
            }

        Filas o columnas como sean posibles:
        Para que el contenedor admita la cantidad maxima de columnas posibles.
        
        repeat():
		El 1° valor será auto-fill, el 2° la función minmax() y sus valores serán: tamaño (mínimo) y fr (unidad flexible) maximo.
		O sea, repite los valores de min y max.	
			
			.container {
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
              grid-auto-rows: minmax(100px, auto);
              gap: 20px;
            }

		Posicionamiento sobre líneas:
		Las lineas son definidas por grid, no son los espacios (gutters).
		Usamos valores de inicio y fin en una sola propiedad.	
			
			header {
              grid-column: 1 / 3;
              grid-row: 1;
            }

		Se coloca en la columna 1 hasta la 3ra y se extiende por toda la fila.
		Los valores negativos como -1, -2, -3 solo funcionan con explícita.
		
		Posicionamiento sobre áreas:
		Cada palabra representará una columna/fila y cada línea de nombres representará a una fila.
		
			Usamos grid-template-rows o grid-template-columns:
			Se usa en el contenedor y las palabras van entre comillas, al final ponemos el punto y coma para cerrar la propiedad. 
			Con los nombres debemos replicar la forma en la que queremos que se vea la página.
		
			Reglas:
				Se llenan todas las celdas.
    			Para llenar dos celdas repetimos el nombre.
    			Las areas deben ser solo rectangulares.
    			Las areas no pueden repetirse en lugares diferentes.
			
			.container {
              display: grid;
              grid-template-areas:
                "header header"
                "sidebar content"
                "footer footer";
              grid-template-columns: 1fr 3fr;
              gap: 20px;
            }

            header {
              grid-area: header;
            }	

		Superponiendo elementos:
		Usando las líneas de la cuadrícula con grid-column y grid-row.
		
		Anidación de cuadrículas:
		Tomamos un elemento del contenedor para convertirlo en cuadrícula, no hereda las propiedades del contenedor padre, se acomoda en una cuadrícula aparte.
		
		Cuadrícula de 12/16 columnas:
		Los frameworks para diseñar una cuadrícula se basaban en 12 o 16, pero para esto ya no se necesitan de terceros.
		Podemos hacer estás cuadrículas nativamente.
		Solo necesitamos un contenedor con una cuadrícula de 12 columnas. 
			
			.container {
            	display: grid;
            	grid-template-columns: repeat(12, minmax(0,1fr));
            	gap: 20px;
       		}


	|| FLOAT
		Se utiliza para desplazar un elemento del flujo normal que flotará en el documento para poder ubicarlo en alguna parte de la ventana del navegador.
		Tiene cuatro valores para establecer la flotación a los lados de otros elementos: left, right, none, inherit (heredar propiedades del padre)
		No podemos aplicar propiedades del model box a los elementos que están alrededor para elejarlo, lo aplicamos al float.

			<div class="box">Float</div>
            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam</p>

            .box {
              float: left;
              width: 150px;
              height: 150px;
              margin-right: 30px;
            }
	
		Clear:
		Si solo aplicamos esta propiedad, mueve el flotante y vemos que los elementos circulantes dejan de envolverse al float.
		El problema es que no se integra con los demás elementos.

			.cleared {
			  clear: left;
			}

		display: flow-root
		Creará un bloque que envuelve los elementos para que no sobresalgan en la parte inferior.
		Un BFC (block formatting context) crea un pequeño diseño para que un elemento padre pueda abarcar el tamaño que toman los elementos hijos como son el flotante y el parrafo.
			
			.wrapper {
			  background-color: rgb(79, 185, 227);
			  padding: 10px;
			  color: #fff;
			  display: flow-root;
			}


	|| POSITION
		Se usa para mover elementos desde su ubicación por defecto en el flujo normal hacia otra posición.

		static:
		Valor por defecto en cada elemento.

		relative:
		Permite mover elementos solo respecto a su flujo normal, puede superponerse con otros.
		Para moverlo usamos propiedades como <em>top</em> y <em>left</em> que lo va a empujar desde arriba y desde la izquierda.
			
			.positioned {
              position: relative;
              top: 30px;
              left: 30px;
            }

		Toma estos lados de la caja y los mueve en dirección contraria.

		absolute:
		Saca los elementos del flujo normal, para poder moverlo al borde del <em>html</em> (o de su elemento padre más próximo) para crear elementos de diseño complejo como paneles ocultos en la página que aparecen con un botón.		
		Las propiedades top y left si van hacia arriba y a la izquierda, no empujan desde esas direcciónes como en relative.
		Dependiendo del contenedor padre, dimensionamos el elemento.
			
			.positioned {
              position: absolute;
              top: 30px;
              left: 30px;
            }

        La posición del elemento absoluto depende de su contenedor o ancestro más cercano y no del flujo normal.
			Ej:
			Especifican la distancia que debe estar el elemento desde cada uno de los lados del elemento que lo contiene. 
			Entonces, en este caso, estamos diciendo que el elemento absolutamente posicionado debe estar a 30 px desde la parte superior del "elemento contenedor" y 30 px desde la izquierda.


		Crear contenedor ancestro:
		Si ningún ancestro tiene un valor de position explicito (que nosotros codeamos) tendrá por defecto el valor sticky y su contenedor será el viewport (toda la ventana grafica disponible).
		Necesitamos codear uno:

			position: relative;
		
		Para nuestro ancestro, así el contenedor deja de ser la ventana gráfica.
		El tamaño se podrá definir mejor.

		fixed:
		El elemento flotará fijamente por la ventana del navegador porque es su contenedor natural mientras su ancestro no tenga las propiedades transform o perspective con un valor distinto de none.
			
			.positioned {
              position: fixed;
              top: 30px;
              left: 30px;
            }

		sticky:
		Puede hacer que un elemento esté estatico que se desplazará cuando se mueva la pantalla.
		El elemento sticky solo se desplazará en un área: por todo alto o dimensión de su elemento padre (elemento de bloque, flex o grid más cercado).	
		
			.positioned {
              position: sticky;
              top: 30px;
              left: 30px;
            }

        Si es muy pequeño no se notará que se queda fijo. Con las propiedades top, bottom, left y right lo movemos hacia su lado contrario.
			
			Scrolling index:
			Le agregamos sticky a al elemento <em>dt</em> (description title) de la lista de descripcion (dl). Con un valor maximo de 0 en top, los encabezados se desplazan con el contenido (dd) y cada encabezado siguiente reemplazará al anterior. Con un margen vertical (1em) y horizontal (0).
				
				<h1>Sticky positioning</h1>

					<dl>
					  <dt>A</dt>
					  <dd>Apple</dd>
					  <dd>Ant</dd>
					  <dd>Altimeter</dd>
					  <dt>B</dt>
					</dl>

				dt {
				  background-color: black;
				  color: white;
				  padding: 10px;
				  position: sticky;
				  top: 0;
				  left: 0;
				  margin: 1em 0;
				}

		top, left, right y bottom:

			relative, fixed, sticky:
			Lo usamos para empujar los elementos desde estas direcciones.
			Ej: La propiedad top: 0; hace el elemento no se mueva desde esta posición.

			absolute: 
			Toma distancia de su elemento contenedor.
			Ej: top: 0; toma toda la dimensión top del contenedor.


		Contenedor ancestro más cercano:
		HTML es un jerarquia de elemento relacionados, entre ellos pueden ser:

			Elemento padre: 
			Un elemento que <em>contiene directamente</em> a otros elementos.
		
			Hijo: 
			Elemento que <em>está contenido</em> directamente dentro de otro elemento.
		
			Hermano: 
			Los elementos son hermanos cuando <em>comparten</em> el mismo elemento principal.
		
			antepasado:
			Elemento que contiene <em>en cualquier nivel</em> a otros elementos, será un antepasado de estos.

			descendiente: 
			Elemento que esta <em>está contenido</em> (en cualquier nivel) dentro de otro elemento.
		
		Las áreas de una caja (margin, border, padding, content) pueden ser el contenedor de un elemento posicionado:

		Bloque contenedor y position:
		Para generar un bloque contenedor debe haber un ancestro (más cercano) para el elemento.		
		Determina la posición en donde va a estar ubicado.
		Si un elemento no cumple para ser bloque contenedor, pasa al otro más cercano.	
		Para ser contenedor, un elemento cercano debe tener ciertas caracteristicas:	
				
			Si el elemento es static, relative o sticky:
			El bloque contenedor será el <em>content área</em> del antepasado si es un elemento en bloque, flex o grid. Un elemento en linea no es tenido en cuenta porque no es un bloque contenedor.
			
			Si es absolute: 
			El contenedor será el <em>padding</em> del antepasado mientras no tenga aplicado <span>position: static;</span> o sea, puede tener fixed, absolute, relative. Este truco lo usamos en el apartado de posicionamiento, para que el contenedor del elemento no sea el viewport y se extienda por toda la pantalla.
			
			Si es fixed: 
			El contenedor será el viewport (ventana grafica) del navegador.
			
			Si es absolute o fixed:
			El contenedor puede ser el padding del ancestro si tiene las siguientes propiedades:
				
				transform o perspective distinto del valor none.
				will-change con los valores transform o perspective.
				filter distinto del valor none o will-change (solo en firefox).
				contain con el valor paint.
				backdrop-filter distinto de none.
		
		Mover el BFC:



		z-index:
		Establece el orden de renderización/visualizacion en la página usando el eje z de un elemento posicionado y sus descendientes o de los elementos flexibles.
		Funciona con un elemento posicionado con el valor absolute, fixed o sticky.

			orden html:
			El orden en que aparecen los elementos posicionados en el HTML: los que aparecen últimos se superponen a los que estaban primeros. El eje z es una línea imaginaria que va desde la pantalla hacia nosotros.
		
		Agregamos un valor entero (positivo o negativo) a z-index para subirlo o bajarlo de capa.




	
	|| MULTI-COLUMN
		Podemos acomodar el contenido en columnas mediante un contenedor con algunos elementos.

		Propiedades para el contenedor:
		column-count: Divide el contenido en la cantidad de columnas indicadas.
		column-width: La cantidad de columnas dependera del ancho del contenedor.
			
			Ejemplo:
			<div class="container">
              <h1>Multi-column Layout</h1>

              <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus</p>

              <p>Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada</p>
            </div>  

            .container {
              column-width: 200px;
            }


	|| TABLE
		Se usa para mostrar datos en filas y columnas, mucho tiempo atras se podía usar para diseñar páginas.
		Ahora se puede usar para crear cosas especificas cuando un sitio admite navegadores antiguos.

		display: en los elementos form (table), div (table-row) para una fila. 
		Label e input (<em>table-cell</em>) para las celdas. 
		Para el parrafo que sigue despues del formulario tiene el valor <em>table-caption</em> para el titulo/descripción de la tabla

		Consta de espacios para el form, los campos con margin en 0 (arriba y abajo) y auto (centra horizontalmente), el ancho de los campos estan definidos, etc.
			
			<form>
              <p>First of all, tell us your name and age.</p>
              <div>
                <label for="fname">First name:</label>
                <input type="text" id="fname" />
              </div>

              <div>
                <label for="lname">Last name:</label>
                <input type="text" id="lname" />
              </div>

              <div>
                <label for="age">Age:</label>
                <input type="text" id="age" />
              </div>
            </form>
            
            html {
              font-family: sans-serif;
            }

            form {
              display: table;
              margin: 0 auto;
            }

            form div {
              display: table-row;
            }

            form label,
            form input {
              display: table-cell;
              margin-bottom: 10px;
            }

            form label {
              width: 200px;
              padding-right: 5%;
              text-align: right;
            }

            form input {
              width: 300px;
            }

            form p {
              display: table-caption;
              caption-side: bottom;
              width: 300px;
              color: #999;
              font-style: italic;
            }



*/